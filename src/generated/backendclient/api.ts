/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddReactionRequest
 */
export interface AddReactionRequest {
    /**
     * 
     * @type {string}
     * @memberof AddReactionRequest
     */
    'reaction': string;
    /**
     * 
     * @type {string}
     * @memberof AddReactionRequest
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface Answer
 */
export interface Answer {
    /**
     * 
     * @type {any}
     * @memberof Answer
     */
    'answer'?: any;
    /**
     * 
     * @type {Array<AnswerSource>}
     * @memberof Answer
     */
    'sources': Array<AnswerSource>;
    /**
     * 
     * @type {string}
     * @memberof Answer
     */
    'answer_origin'?: string;
}
/**
 * 
 * @export
 * @interface AnswerRequest
 */
export interface AnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof AnswerRequest
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof AnswerRequest
     */
    'thread_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerRequest
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerRequest
     */
    'document_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof AnswerRequest
     */
    'tag_filter'?: object;
    /**
     * 
     * @type {number}
     * @memberof AnswerRequest
     */
    'validation_threshold'?: number;
}
/**
 * 
 * @export
 * @interface AnswerResponse
 */
export interface AnswerResponse {
    /**
     * 
     * @type {Array<Answer>}
     * @memberof AnswerResponse
     */
    'answers': Array<Answer>;
}
/**
 * 
 * @export
 * @interface AnswerSource
 */
export interface AnswerSource {
    /**
     * 
     * @type {DocumentSection}
     * @memberof AnswerSource
     */
    'source_section': DocumentSection;
    /**
     * 
     * @type {number}
     * @memberof AnswerSource
     */
    'score': number;
    /**
     * 
     * @type {object}
     * @memberof AnswerSource
     */
    'document_tag'?: object;
}
/**
 * 
 * @export
 * @interface ConnectModelRequest
 */
export interface ConnectModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectModelRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectModelRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CreateThreadRequest
 */
export interface CreateThreadRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateThreadRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface CreateThreadResponse
 */
export interface CreateThreadResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateThreadResponse
     */
    'thread_id': string;
}
/**
 * 
 * @export
 * @interface DocumentSection
 */
export interface DocumentSection {
    /**
     * 
     * @type {string}
     * @memberof DocumentSection
     */
    'embedding_id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentSection
     */
    'document_id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentSection
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentSection
     */
    'starting_text': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentSection
     */
    'offset': number;
}
/**
 * 
 * @export
 * @interface EditMessageRequest
 */
export interface EditMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof EditMessageRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof EditMessageRequest
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ExternalDocument
 */
export interface ExternalDocument {
    /**
     * 
     * @type {string}
     * @memberof ExternalDocument
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalDocument
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof ExternalDocument
     */
    'tags'?: object;
}
/**
 * 
 * @export
 * @interface ExtractedField
 */
export interface ExtractedField {
    /**
     * 
     * @type {string}
     * @memberof ExtractedField
     */
    'key': string;
    /**
     * 
     * @type {any}
     * @memberof ExtractedField
     */
    'value'?: any;
    /**
     * 
     * @type {Array<AnswerSource>}
     * @memberof ExtractedField
     */
    'sources': Array<AnswerSource>;
}
/**
 * 
 * @export
 * @interface ExtractionRequest
 */
export interface ExtractionRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtractionRequest
     */
    'document_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtractionRequest
     */
    'fields': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ExtractionRequest
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface ExtractionResponse
 */
export interface ExtractionResponse {
    /**
     * 
     * @type {{ [key: string]: ExtractedField; }}
     * @memberof ExtractionResponse
     */
    'fields': { [key: string]: ExtractedField; };
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface IndexExternalUrlsRequest
 */
export interface IndexExternalUrlsRequest {
    /**
     * 
     * @type {Array<ExternalDocument>}
     * @memberof IndexExternalUrlsRequest
     */
    'documents': Array<ExternalDocument>;
    /**
     * 
     * @type {string}
     * @memberof IndexExternalUrlsRequest
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface IndexRequest
 */
export interface IndexRequest {
    /**
     * 
     * @type {string}
     * @memberof IndexRequest
     */
    'document_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexRequest
     */
    'document_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexRequest
     */
    'document_text': string;
    /**
     * 
     * @type {object}
     * @memberof IndexRequest
     */
    'tags'?: object;
}
/**
 * 
 * @export
 * @interface IndexUrlsResponse
 */
export interface IndexUrlsResponse {
    /**
     * 
     * @type {Array<IndexedUrl>}
     * @memberof IndexUrlsResponse
     */
    'indexed_urls': Array<IndexedUrl>;
}
/**
 * 
 * @export
 * @interface IndexedDocument
 */
export interface IndexedDocument {
    /**
     * 
     * @type {string}
     * @memberof IndexedDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IndexedDocument
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof IndexedDocument
     */
    'tags'?: object;
}
/**
 * 
 * @export
 * @interface IndexedDocuments
 */
export interface IndexedDocuments {
    /**
     * 
     * @type {Array<IndexedDocument>}
     * @memberof IndexedDocuments
     */
    'documents': Array<IndexedDocument>;
}
/**
 * 
 * @export
 * @interface IndexedUrl
 */
export interface IndexedUrl {
    /**
     * 
     * @type {string}
     * @memberof IndexedUrl
     */
    'document_id': string;
    /**
     * 
     * @type {string}
     * @memberof IndexedUrl
     */
    'document_title': string;
}
/**
 * 
 * @export
 * @interface ListThreadsResponse
 */
export interface ListThreadsResponse {
    /**
     * 
     * @type {Array<ThreadResponse>}
     * @memberof ListThreadsResponse
     */
    'threads': Array<ThreadResponse>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'text': string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageResponse
     */
    'is_user': boolean;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'thread_id': string;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'timestamp': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof MessageResponse
     */
    'reactions': { [key: string]: number; };
    /**
     * 
     * @type {Array<AnswerSource>}
     * @memberof MessageResponse
     */
    'sources': Array<AnswerSource>;
}
/**
 * 
 * @export
 * @interface MessagesResponse
 */
export interface MessagesResponse {
    /**
     * 
     * @type {Array<MessageResponse>}
     * @memberof MessagesResponse
     */
    'messages': Array<MessageResponse>;
}
/**
 * 
 * @export
 * @interface TestModelConnectionRequest
 */
export interface TestModelConnectionRequest {
    /**
     * 
     * @type {string}
     * @memberof TestModelConnectionRequest
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface TestModelConnectionResponse
 */
export interface TestModelConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof TestModelConnectionResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ThreadResponse
 */
export interface ThreadResponse {
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof ThreadResponse
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Answer
         * @param {AnswerRequest} answerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerApiAnswerPost: async (answerRequest: AnswerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'answerRequest' is not null or undefined
            assertParamExists('answerApiAnswerPost', 'answerRequest', answerRequest)
            const localVarPath = `/api/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(answerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Answer Thread
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerThreadApiThreadsThreadIdGet: async (threadId: string, userId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('answerThreadApiThreadsThreadIdGet', 'threadId', threadId)
            const localVarPath = `/api/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Thread
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadApiThreadsPost: async (createThreadRequest: CreateThreadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createThreadRequest' is not null or undefined
            assertParamExists('createThreadApiThreadsPost', 'createThreadRequest', createThreadRequest)
            const localVarPath = `/api/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Thread Callback
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThreadCallbackApiThreadsThreadIdDelete: async (threadId: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('deleteThreadCallbackApiThreadsThreadIdDelete', 'threadId', threadId)
            const localVarPath = `/api/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Message
         * @param {string} messageId 
         * @param {EditMessageRequest} editMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessageApiMessageMessageIdPost: async (messageId: string, editMessageRequest: EditMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('editMessageApiMessageMessageIdPost', 'messageId', messageId)
            // verify required parameter 'editMessageRequest' is not null or undefined
            assertParamExists('editMessageApiMessageMessageIdPost', 'editMessageRequest', editMessageRequest)
            const localVarPath = `/api/message/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extract
         * @param {ExtractionRequest} extractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractApiExtractPost: async (extractionRequest: ExtractionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extractionRequest' is not null or undefined
            assertParamExists('extractApiExtractPost', 'extractionRequest', extractionRequest)
            const localVarPath = `/api/extract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Threads
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadsApiThreadsGet: async (userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index Doc
         * @param {IndexRequest} indexRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexDocApiIndexPost: async (indexRequest: IndexRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexRequest' is not null or undefined
            assertParamExists('indexDocApiIndexPost', 'indexRequest', indexRequest)
            const localVarPath = `/api/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(indexRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index From Urls
         * @param {IndexExternalUrlsRequest} indexExternalUrlsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexFromUrlsApiIndexUrlsPost: async (indexExternalUrlsRequest: IndexExternalUrlsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexExternalUrlsRequest' is not null or undefined
            assertParamExists('indexFromUrlsApiIndexUrlsPost', 'indexExternalUrlsRequest', indexExternalUrlsRequest)
            const localVarPath = `/api/index/urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(indexExternalUrlsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index Pdf
         * @param {string} documentId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexPdfApiIndexPdfDocumentIdPost: async (documentId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('indexPdfApiIndexPdfDocumentIdPost', 'documentId', documentId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('indexPdfApiIndexPdfDocumentIdPost', 'file', file)
            const localVarPath = `/api/index_pdf/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Init Model
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initModelAdminConnectPost: async (connectModelRequest: ConnectModelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectModelRequest' is not null or undefined
            assertParamExists('initModelAdminConnectPost', 'connectModelRequest', connectModelRequest)
            const localVarPath = `/admin/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Documents
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsApiDocumentsGet: async (limit?: number, offset?: number, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAdminResetIndexDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/reset_index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Model Backend
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setModelBackendAdminSetModelBackendPost: async (connectModelRequest: ConnectModelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectModelRequest' is not null or undefined
            assertParamExists('setModelBackendAdminSetModelBackendPost', 'connectModelRequest', connectModelRequest)
            const localVarPath = `/admin/set_model_backend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Show Website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWebsiteGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test Connection
         * @param {TestModelConnectionRequest} testModelConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionAdminTestConnectionPost: async (testModelConnectionRequest: TestModelConnectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testModelConnectionRequest' is not null or undefined
            assertParamExists('testConnectionAdminTestConnectionPost', 'testModelConnectionRequest', testModelConnectionRequest)
            const localVarPath = `/admin/test_connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testModelConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle Reaction
         * @param {string} messageId 
         * @param {AddReactionRequest} addReactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleReactionApiMessageMessageIdReactionPost: async (messageId: string, addReactionRequest: AddReactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('toggleReactionApiMessageMessageIdReactionPost', 'messageId', messageId)
            // verify required parameter 'addReactionRequest' is not null or undefined
            assertParamExists('toggleReactionApiMessageMessageIdReactionPost', 'addReactionRequest', addReactionRequest)
            const localVarPath = `/api/message/{message_id}/reaction`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addReactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Answer
         * @param {AnswerRequest} answerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerApiAnswerPost(answerRequest: AnswerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnswerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerApiAnswerPost(answerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Answer Thread
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async answerThreadApiThreadsThreadIdGet(threadId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.answerThreadApiThreadsThreadIdGet(threadId, userId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Thread
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThreadApiThreadsPost(createThreadRequest: CreateThreadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThreadApiThreadsPost(createThreadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Thread Callback
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThreadCallbackApiThreadsThreadIdDelete(threadId: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThreadCallbackApiThreadsThreadIdDelete(threadId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Message
         * @param {string} messageId 
         * @param {EditMessageRequest} editMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMessageApiMessageMessageIdPost(messageId: string, editMessageRequest: EditMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editMessageApiMessageMessageIdPost(messageId, editMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Extract
         * @param {ExtractionRequest} extractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractApiExtractPost(extractionRequest: ExtractionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractApiExtractPost(extractionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Threads
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadsApiThreadsGet(userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListThreadsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadsApiThreadsGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Index Doc
         * @param {IndexRequest} indexRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexDocApiIndexPost(indexRequest: IndexRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexDocApiIndexPost(indexRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Index From Urls
         * @param {IndexExternalUrlsRequest} indexExternalUrlsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest: IndexExternalUrlsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexUrlsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Index Pdf
         * @param {string} documentId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexPdfApiIndexPdfDocumentIdPost(documentId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexPdfApiIndexPdfDocumentIdPost(documentId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Init Model
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initModelAdminConnectPost(connectModelRequest: ConnectModelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initModelAdminConnectPost(connectModelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Documents
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocumentsApiDocumentsGet(limit?: number, offset?: number, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexedDocuments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocumentsApiDocumentsGet(limit, offset, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeAdminResetIndexDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeAdminResetIndexDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Model Backend
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setModelBackendAdminSetModelBackendPost(connectModelRequest: ConnectModelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setModelBackendAdminSetModelBackendPost(connectModelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Show Website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showWebsiteGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showWebsiteGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test Connection
         * @param {TestModelConnectionRequest} testModelConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testConnectionAdminTestConnectionPost(testModelConnectionRequest: TestModelConnectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestModelConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testConnectionAdminTestConnectionPost(testModelConnectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Toggle Reaction
         * @param {string} messageId 
         * @param {AddReactionRequest} addReactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleReactionApiMessageMessageIdReactionPost(messageId: string, addReactionRequest: AddReactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleReactionApiMessageMessageIdReactionPost(messageId, addReactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Answer
         * @param {AnswerRequest} answerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerApiAnswerPost(answerRequest: AnswerRequest, options?: any): AxiosPromise<AnswerResponse> {
            return localVarFp.answerApiAnswerPost(answerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Answer Thread
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        answerThreadApiThreadsThreadIdGet(threadId: string, userId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<MessagesResponse> {
            return localVarFp.answerThreadApiThreadsThreadIdGet(threadId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Thread
         * @param {CreateThreadRequest} createThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadApiThreadsPost(createThreadRequest: CreateThreadRequest, options?: any): AxiosPromise<CreateThreadResponse> {
            return localVarFp.createThreadApiThreadsPost(createThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Thread Callback
         * @param {string} threadId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThreadCallbackApiThreadsThreadIdDelete(threadId: string, userId?: string, options?: any): AxiosPromise<any> {
            return localVarFp.deleteThreadCallbackApiThreadsThreadIdDelete(threadId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Message
         * @param {string} messageId 
         * @param {EditMessageRequest} editMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessageApiMessageMessageIdPost(messageId: string, editMessageRequest: EditMessageRequest, options?: any): AxiosPromise<any> {
            return localVarFp.editMessageApiMessageMessageIdPost(messageId, editMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extract
         * @param {ExtractionRequest} extractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractApiExtractPost(extractionRequest: ExtractionRequest, options?: any): AxiosPromise<ExtractionResponse> {
            return localVarFp.extractApiExtractPost(extractionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Threads
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadsApiThreadsGet(userId?: string, options?: any): AxiosPromise<ListThreadsResponse> {
            return localVarFp.getThreadsApiThreadsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Index Doc
         * @param {IndexRequest} indexRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexDocApiIndexPost(indexRequest: IndexRequest, options?: any): AxiosPromise<any> {
            return localVarFp.indexDocApiIndexPost(indexRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Index From Urls
         * @param {IndexExternalUrlsRequest} indexExternalUrlsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest: IndexExternalUrlsRequest, options?: any): AxiosPromise<IndexUrlsResponse> {
            return localVarFp.indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Index Pdf
         * @param {string} documentId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexPdfApiIndexPdfDocumentIdPost(documentId: string, file: File, options?: any): AxiosPromise<any> {
            return localVarFp.indexPdfApiIndexPdfDocumentIdPost(documentId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Init Model
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initModelAdminConnectPost(connectModelRequest: ConnectModelRequest, options?: any): AxiosPromise<any> {
            return localVarFp.initModelAdminConnectPost(connectModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Documents
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsApiDocumentsGet(limit?: number, offset?: number, userId?: string, options?: any): AxiosPromise<IndexedDocuments> {
            return localVarFp.listDocumentsApiDocumentsGet(limit, offset, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeAdminResetIndexDelete(options?: any): AxiosPromise<any> {
            return localVarFp.purgeAdminResetIndexDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Model Backend
         * @param {ConnectModelRequest} connectModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setModelBackendAdminSetModelBackendPost(connectModelRequest: ConnectModelRequest, options?: any): AxiosPromise<any> {
            return localVarFp.setModelBackendAdminSetModelBackendPost(connectModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Show Website
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWebsiteGet(options?: any): AxiosPromise<any> {
            return localVarFp.showWebsiteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test Connection
         * @param {TestModelConnectionRequest} testModelConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionAdminTestConnectionPost(testModelConnectionRequest: TestModelConnectionRequest, options?: any): AxiosPromise<TestModelConnectionResponse> {
            return localVarFp.testConnectionAdminTestConnectionPost(testModelConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle Reaction
         * @param {string} messageId 
         * @param {AddReactionRequest} addReactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleReactionApiMessageMessageIdReactionPost(messageId: string, addReactionRequest: AddReactionRequest, options?: any): AxiosPromise<any> {
            return localVarFp.toggleReactionApiMessageMessageIdReactionPost(messageId, addReactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Answer
     * @param {AnswerRequest} answerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public answerApiAnswerPost(answerRequest: AnswerRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).answerApiAnswerPost(answerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Answer Thread
     * @param {string} threadId 
     * @param {string} [userId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public answerThreadApiThreadsThreadIdGet(threadId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).answerThreadApiThreadsThreadIdGet(threadId, userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Thread
     * @param {CreateThreadRequest} createThreadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createThreadApiThreadsPost(createThreadRequest: CreateThreadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createThreadApiThreadsPost(createThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Thread Callback
     * @param {string} threadId 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteThreadCallbackApiThreadsThreadIdDelete(threadId: string, userId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteThreadCallbackApiThreadsThreadIdDelete(threadId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Message
     * @param {string} messageId 
     * @param {EditMessageRequest} editMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editMessageApiMessageMessageIdPost(messageId: string, editMessageRequest: EditMessageRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).editMessageApiMessageMessageIdPost(messageId, editMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extract
     * @param {ExtractionRequest} extractionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extractApiExtractPost(extractionRequest: ExtractionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extractApiExtractPost(extractionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Threads
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThreadsApiThreadsGet(userId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getThreadsApiThreadsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Index Doc
     * @param {IndexRequest} indexRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indexDocApiIndexPost(indexRequest: IndexRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indexDocApiIndexPost(indexRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Index From Urls
     * @param {IndexExternalUrlsRequest} indexExternalUrlsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest: IndexExternalUrlsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indexFromUrlsApiIndexUrlsPost(indexExternalUrlsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Index Pdf
     * @param {string} documentId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public indexPdfApiIndexPdfDocumentIdPost(documentId: string, file: File, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).indexPdfApiIndexPdfDocumentIdPost(documentId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Init Model
     * @param {ConnectModelRequest} connectModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public initModelAdminConnectPost(connectModelRequest: ConnectModelRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).initModelAdminConnectPost(connectModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Documents
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDocumentsApiDocumentsGet(limit?: number, offset?: number, userId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDocumentsApiDocumentsGet(limit, offset, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purgeAdminResetIndexDelete(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purgeAdminResetIndexDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Model Backend
     * @param {ConnectModelRequest} connectModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setModelBackendAdminSetModelBackendPost(connectModelRequest: ConnectModelRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setModelBackendAdminSetModelBackendPost(connectModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Show Website
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showWebsiteGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).showWebsiteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test Connection
     * @param {TestModelConnectionRequest} testModelConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public testConnectionAdminTestConnectionPost(testModelConnectionRequest: TestModelConnectionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).testConnectionAdminTestConnectionPost(testModelConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle Reaction
     * @param {string} messageId 
     * @param {AddReactionRequest} addReactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toggleReactionApiMessageMessageIdReactionPost(messageId: string, addReactionRequest: AddReactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toggleReactionApiMessageMessageIdReactionPost(messageId, addReactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


